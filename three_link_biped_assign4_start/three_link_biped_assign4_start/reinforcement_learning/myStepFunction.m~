function [NextObs, Reward, IsDone, LoggedSignals] = myStepFunction(Action, LoggedSignals)

    numObs = size(LoggedSignals.State, 1);
    state = reshape(LoggedSignals.State, [numObs, 1]);
    q0 = state(1:3, :);
    dq0 = state(4:6, :);
    
    sln = solve_eqns_by_time(q0, dq0, LoggedSignals.Ts, Action);
    y0 = sln.Y{end}(end, :)
    if isempty(sln.TE{end})
        LoggedSignals.pivotFoot = mod(size(sln.TE, 2) - 1 + LoggedSignals.pivotFoot, 2);
    else 
        LoggedSignals.pivotFoot = mod(size(sln.TE, 2) + LoggedSignals.pivotFoot, 2);
    end
    LoggedSignals.State = [sln.Y{end}(end, :)' ; LoggedSignals.pivotFoot];
    %LoggedSignals.State = sln.Y{end}(end, :)';
    LoggedSignals.x0 = LoggedSignals.x0 + sln.X0{end};
    LoggedSignals.T = LoggedSignals.T + LoggedSignals.Ts;

    NextObs = LoggedSignals.State;
    
    [x_h, z_h, dx_h, ~] = kin_hip(NextObs(1:3), NextObs(4:6));
    [x_swf, z_swf, dx_swf, ~] = kin_swf(NextObs(1:3), NextObs(4:6));

    
    %% Reward
    r_zh = -0.04 * (z_h - 0.45)^2;
    r_dxh = 0.004 * dx_h;
    r_t = 1 * LoggedSignals.T / LoggedSignals.Tf;
    r_u = -1e-5 * norm(Action)^2;
    r_swf = -0.001 * (z_swf > z_h);
    
    Reward = r_zh + r_dxh + r_t + r_u + r_swf;
    LoggedSignals.x_swf = LoggedSignals.x0 + x_swf;
    
    IsDone = false;
    if (z_h < 0 || z_swf < -0.2)
        IsDone = true;
    end
    
    if (LoggedSignals.T > LoggedSignals.Tf)
        IsDone = true;
        Reward = Reward + 10;
    end
end